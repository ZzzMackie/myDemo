<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <!-- <script src="//ossweb-img.qq.com/images/js/jquery/jquery-1.11.3.min.js"></script> -->
</head>
<style>
    html,
    body {
        position: fixed;
        width: 100%;
        height: 100%;
    }
    /* 极速建站-切换样板 新loading */
    
    .fk-forWaiting {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 9032;
        opacity: 0.8;
        filter: alpha(opacity=80);
        background-color: #000;
    }
    
    .fk-forWaiting .f-spinner {
        position: absolute;
        top: 50%;
        left: 50%;
    }
    
    .f-spinner {
        width: 40px;
        height: 40px;
        margin: -20px 0 0 -20px;
    }
    
    .fk-forWaiting-ie .f-spinner {
        width: 60px;
        height: 60px;
        margin: -30px 0 0 -30px;
        background: url(/image/loading/loading.gif?v=201807251417) no-repeat 0 0;
    }
    
    .fk-forWaiting .f-loadingTip {
        width: 240px;
        color: #fff;
        font-size: 12px;
        font-family: 微软雅黑, 'microsoft yahei', 宋体, 新宋体, sans-serif;
        text-align: center;
        position: absolute;
    }
    
    .fk-forWaiting-ie .f-loadingTip {
        bottom: -30px;
        left: -81px;
    }
    
    .fk-forWaiting-normal .f-loadingTip {
        bottom: -36px;
        left: -90px;
    }
    
    .f-new-spinner>.f-spinnerContainer {
        width: 10px;
        height: 10px;
        background-color: #fff;
        border-radius: 50%;
        position: absolute;
    }
    
    .f-new-spinner .f-spinnerContainer {
        position: absolute;
    }
    
    .f-new-spinner .f-spinnerContainer:nth-child(1) {
        left: 0px;
        animation: fk-bouncedelay 1.5s infinite cubic-bezier(.59, .27, .03, .13);
    }
    
    .f-new-spinner .f-spinnerContainer:nth-child(2) {
        animation: fk-bouncedelay2 1.5s infinite cubic-bezier(.59, .27, .03, .13);
        right: 0px;
    }
    
    .f-new-spinner .f-spinnerContainer:nth-child(3) {
        animation: fk-bouncedelay3 1.5s infinite cubic-bezier(.59, .27, .03, .13);
        left: 0px;
        bottom: 0px;
    }
    
    .f-new-spinner .f-spinnerContainer:nth-child(4) {
        animation: fk-bouncedelay4 1.5s infinite cubic-bezier(.59, .27, .03, .13);
        right: 0px;
        bottom: 0px;
    }
    
    .f-new-spinner {
        animation: fk-loadingdelay 1.2s infinite linear;
    }
    
    .f-spinnerContainer {
        /* animation-delay: 1.8s; */
    }
    
    @-webkit-keyframes fk-loadingdelay {
        0% {
            -webkit-transform: rotate(0deg)
        }
        50% {
            -webkit-transform: rotate(360deg)
        }
        100% {
            -webkit-transform: rotate(720deg)
        }
    }
    
    @keyframes fk-loadingdelay {
        0% {
            transform: rotate(0deg);
            -webkit-transform: rotate(0deg);
        }
        65% {
            transform: rotate(360deg);
            -webkit-transform: rotate(360deg);
        }
        100% {
            transform: rotate(720deg);
            -webkit-transform: rotate(720deg);
        }
    }
    
    @keyframes fk-bouncedelay {
        0%,
        100% {
            transform: translate3d(0);
            top: 0;
            left: 0;
            -webkit-transform: translate3d(0, 0, 0);
        }
        50% {
            transform: translate3d(0);
            -webkit-transform: translate3d(-50%, -50%, 0);
            top: 50%;
            left: 50%;
        }
    }
    
    @keyframes fk-bouncedelay2 {
        0%,
        100% {
            transform: translate3d(0);
            top: 0;
            right: 0;
            -webkit-transform: translate3d(0, 0, 0);
        }
        50% {
            transform: translate3d(0);
            -webkit-transform: translate3d(50%, -50%, 0);
            top: 50%;
            right: 50%;
        }
    }
    
    @keyframes fk-bouncedelay3 {
        0%,
        100% {
            transform: translate3d(0);
            bottom: 0;
            left: 0;
            -webkit-transform: translate3d(0, 0, 0);
        }
        50% {
            transform: translate3d(0);
            -webkit-transform: translate3d(-50%, 50%, 0);
            bottom: 50%;
            left: 50%;
        }
    }
    
    @keyframes fk-bouncedelay4 {
        0%,
        100% {
            transform: translate3d(0);
            bottom: 0;
            right: 0;
            -webkit-transform: translate3d(0, 0, 0);
        }
        50% {
            transform: translate3d(0);
            -webkit-transform: translate3d(50%, 50%, 0);
            bottom: 50%;
            right: 50%;
        }
    }
    #mocha{
    background-image: -webkit-linear-gradient(0deg, rgb(245, 81, 30) 0%, rgb(0, 0, 0) 100%);
    background-image: -moz-linear-gradient(0deg, rgb(245, 81, 30) 0%, rgb(0, 0, 0) 100%);
    background-image: -ms-linear-gradient(0deg, rgb(245, 81, 30) 0%, rgb(0, 0, 0) 100%);
    background-image: linear-gradient(0deg, rgb(245, 81, 30) 0%, rgb(0, 0, 0) 100%);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
  }
</style>

<body>
    <div id="mocha">daosidas da sd as </div>
    <!-- <img src="" alt=" "> -->
    <!-- <svg id="jzm-m70" viewBox="0 0 42 42"><title>画板 1</title><path d="M10.74,25H10.6L8.9,17a2,2,0,0,1,2-2h20a2.05,2.05,0,0,1,2,3H22c-1.6,0-3.08,0-3.42,1.92s-.43,2.59-.5,3.07a2,2,0,0,1-2,2Z" fill="none" stroke="#000" stroke-miterlimit="10" stroke-width="2"></path><path d="M11,28l9.82,0c.84,0,1.56-.09,1.92-2,.24-1.25.37-1.91.57-3.22S24.08,21,25.87,21H31.5c.85,0,.94,0,.73,1s-.37,2-.37,2h-4a1.5,1.5,0,0,0,0,3h3.49s-.13.8-.51,2.59C30.55,31,29.47,31,28,31H13.16C12.15,31,11.37,30.18,11,28Z" fill="none" stroke="#000" stroke-miterlimit="10" stroke-width="2"></path><path d="M25.31,15a4.32,4.32,0,0,0-8.62,0Z" fill="none" stroke="#000" stroke-miterlimit="10" stroke-width="2"></path></svg>
    <div class="fk-forWaiting">
        <div class="f-spinner f-new-spinner">

            <div class="f-spinnerContainer"></div>
            <div class="f-spinnerContainer"></div>
            <div class="f-spinnerContainer"></div>
            <div class="f-spinnerContainer"></div>
        </div>
    </div> -->
    <script>
        const filterFn = () => true;
        function getTag (val) {
            return Object.prototype.toString.call(val);
        }
        function baseMerge(target, filterFn, ...sources) {
            if (!target) target = {};
            
            // target = {...target,...sources}
            // return target;
            sources.filter(v => v && typeof v === 'object').forEach(source => {
                Object
                    .keys(source)
                    .forEach(key => {
                        const targetTag = getTag(target[key]);
                        const sourceTag = getTag(source[key]);

                        if (sourceTag === '[object Array]' || sourceTag === '[object Object]') {
                            if (targetTag !== sourceTag) target[key] = sourceTag === '[object Array]' ? [] : {};
                            baseMerge(target[key], filterFn, source[key]);
                        } else if (filterFn(target, source, key)) {
                            target[key] = source[key];
                        }
                    });
            });

            return target;
        }

        function merge(target, ...sources) {
            return baseMerge(target, filterFn, ...sources);
        }
        const catchObj = {
            base: document.getElementsByClassName('f-spinnerContainer')[0],
            b: {
                c: 1,
                d: [1, 2, 3]
            },
            vv: 'sasda',
            cat: function() {
                console.log(1)
            }
        };
        let catchObj1 = {
            d:[4],
            b:{d:{a:1}},
            canPreview: true,
            advance: true,
            openGradientMode: true,
            noAlpha: false,
            top: 0,
            left: 0,
            defaultColor: null,
            themeColor: null,
            initialColor: null,
            base: null,
            format: 'rgba',
            direction: 'right'
        }
        // catchObj1 = {...catchObj1,
        //     ...catchObj
        // };
        var a = merge(catchObj1,{cccc:2},catchObj)
        console.log(catchObj1)
        // catchObj1 = catchObj;
        // console.log(catchObj1)
            // $('img').load(()=>{
            //     $('img').attr('src','../pjcDemo/img/0.jpg')
            // })
            /**
             * 1.什么是复杂度分析
                1.数据结构和算法解决是如何让计算机更快时间更省空间的解决问题
                2.因此需要从执行时间和占用空间2个维度来评估数据结构和算法的性能
                3.分别用时间复杂度和空间复杂度2个概念来描述性能问题
                4.复杂度描述是算法执行时间（或占用空间）与数据规模的增长关系

             * 2.为什么要进行复杂度分析？
                1.和性能测试相比，复杂度分析有不依赖执行环境，成本低，效率高，易操作，指导性强的特点
                2.掌握复杂度分析，将能边写出性能更优的代码，有利于降低系统开发和维护成本

             * 3.如何进行？
                1.大O表示法
                    算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中Tn表示算法执行总时间，fn表示每行代码执行的总次数，而n
                    往往表示数据的规模。这就是大O时间复杂度表示法
                2.时间复杂度
                    1.定义
                        算法的时间复杂度，也就是算法时间的量度
                        大O时间复杂度表示法，实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫渐进时间复杂度
                        简称时间复杂度
                        假设一个方法需要执行（n^2+n+n+1+1+1） = n^2+2n+3
                        那么他的T(n) = O(n^2)
                    2.特点
                        以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量、低价，系数实际上对这种增长趋势不产生绝对
                        性影响，所以在做分析时 忽略这些项，所以上面的时间复杂度为O(n^2)
                3.分析
                    1.只关注循环执行次数最多的一段代码
                        单段代码看高频：比如循环
                        执行次数最多的是循环及里面的代码执行了n次 所以复杂度为O(n)
                    2.加法法则：总复杂度等于量级最大的那段代码的复杂度
                        多段代码取最大，比如一段代码中有单循环和多重循环，那么取多重循环的复杂度 例如下面的冒泡排序 多重循环所以他的T(n) = O(n*n) = O (n^2)
                    3.乘法法则：嵌套代码的复杂度等于嵌套内外代码的复杂度的乘积
                        嵌套代码求乘积：比如递归，多重循环等
                        一个方法a循环里面调用f方法，而f方法里面也有循环 所以 a方法的时间复杂度就是T(n) = Ta(n) * Tf(n) = O(n*n) = O(n^2)
                    4.多个规模求加法：比如方法有俩个参数控制俩个循环的次数，那么这是就取二者复杂度相加
                        T(n)+T(m)=O(m+n)
                    5.多个规模求乘法：比如方法有俩个参数控制多重循环的次数，那么就取二者复杂度相乘
                        T(n)=O(m*n)
                4.常见的时间复杂度分析
                    1.多项式阶
                        随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长
                    O(1)常数阶 O(logn)对数阶 O(n)线性阶 O(nlogn)线性对数阶 O(n^2)平方阶 O(n^3)立方阶

             * 
             *  
            */
            // function swap(arr, left, right) {
            //     [arr[left], arr[right]] = [arr[right], arr[left]];
            // }

        // function isError(arr) {
        //     if (!Array.isArray(arr)) throw new Error('arr is not Array!!');
        // }
        // // 平均时间复杂度O(n^2) 不稳定  大O表示法 时间复杂度表示的是
        // // 最佳情况：T(n) = O(n) 正序数组
        // function bubbleSort(arr) {
        //     console.time('bubbleSort')
        //     isError(arr);
        //     for (let i = arr.length; i >= 2; --i) {
        //         var swapped = false;
        //         for (let j = 0; j < arr.length; j++) {
        //             if (arr[j] > arr[j + 1]) {
        //                 swap(arr, j, j + 1);
        //                 swapped = true;
        //             }
        //         }
        //         if (!swapped) break;
        //     }
        //     console.timeEnd('bubbleSort')
        //     return arr;
        // }
        // console.log(bubbleSort([5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8]))

        // // 它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
        // // 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
        // //适合用在数据规模比较小 30个左右
        // // 平均时间复杂度O(n^2) 稳定
        // // 最佳情况：T(n) = O(n) 正序数组
        // function insertionSort(arr) {
        //     console.time('insertionSort')
        //     isError(arr);
        //     for (let i = 1; i < arr.length; i++) {
        //         for (let right = i; arr[right] < arr[right - 1]; right--) {
        //             swap(arr, right, right - 1);
        //         }
        //     }
        //     console.timeEnd('insertionSort')
        //     return arr;
        // }
        // console.log(insertionSort([5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8]))

        // // 平均时间复杂度O(n) 不稳定
        // // 处理大数据最快的排序算法之一
        // // 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
        // function quickSort(arr) {
        //     console.time('quickSort')
        //     isError(arr);
        //     if (arr.length <= 1) return arr;
        //     const MID = arr.length / 2 | 0,
        //         midNum = arr.splice(MID, 1)[0],
        //         left = [],
        //         right = [];
        //     for (let i = 0; i < arr.length; i++) {
        //         arr[i] < midNum ? left.push(arr[i]) : right.push(arr[i]);
        //     }
        //     console.timeEnd('quickSort')
        //     return quickSort(left).concat([midNum], quickSort(right));
        // }
        // console.log("TCL: quickSort([5,0,1,9,10,11,9,9,8])", quickSort([5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8]))

        // // 表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，
        // // 数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。
        // // 平均时间复杂度O(n^2) 不稳定
        // function selectionSort(arr) {
        //     console.time('selection')
        //     isError(arr);
        //     if (arr.length <= 1) return arr;
        //     for (let i = 0; i < arr.length; i++) {
        //         var temp = i;
        //         for (let j = i + 1; j < arr.length; j++) {
        //             if (arr[j] < arr[temp]) {
        //                 temp = j

        //             }
        //         }
        //         if (temp !== arr[i]) {
        //             swap(arr, temp, i);
        //         }
        //     }
        //     console.timeEnd('selection')
        //     return arr;
        // }
        // console.log("TCL: selectionSort([5,0,1,9,10,11,9,9,8])", selectionSort([5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8]))

        // // 平均时间复杂度O(nlogn) 稳定
        // //  最佳情况：T(n) = O(n)
        // function mergeSort(arr) {
        //     isError(arr);
        //     if (arr.length <= 1) return arr;
        //     const MID = arr.length / 2 | 0,
        //         left = arr.slice(0, MID),
        //         right = arr.slice(MID);
        //     return merge(mergeSort(left), mergeSort(right));
        // }

        // function merge(left, right) {
        //     var newarr = [];
        //     while (left.length && right.length) {
        //         left[0] <= right[0] ? newarr.push(left.shift()) : newarr.push(right.shift());
        //     }
        //     return newarr.concat(left, right);
        // }
        // console.log("TCL: mergeSort([5,0,1,9,10,11,9,9,8])", mergeSort([5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8]))

        // function binary_searh(low, high, key, arr) {

        //     if (low > high) return -1;
        //     const MID = (low + high) / 2 | 0;
        //     console.time('binary_searh')
        //     while (low < high) {
        //         if (key === arr[MID]) {
        //             return MID;
        //         } else if (key > arr[MID]) {
        //             low = MID + 1;
        //             return binary_searh(low, high, key, arr);
        //         } else {
        //             high = MID - 1;
        //             return binary_searh(low, high, key, arr);
        //         }
        //     }
        //     console.timeEnd('binary_searh')
        // }
        // console.log(binary_searh(0, 26, 5, mergeSort([5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8, 5, 0, 1, 9, 10, 11, 9, 9, 8])))

        // var twoSum = function (nums, target) {
        //     const comp = {};

        //     for (let i = 0; i < nums.length; i++) {
        //         if (comp[nums[i]] >= 0) {//如果数组当前位的值等于对象的key值
        //             return [comp[nums[i]], i]//返回对象key属性值即为之前记录的下标，和当前找到的值得索引的数组
        //         }
        //         comp[target - nums[i]] = i; //将目标值减去当前值所得到的值作为key，索引作为值
        //         console.log(comp);
        //     }
        // };
        // console.log("TCL: twoSum([3,7,11,2,6,15],9)", twoSum([3, 7, 11, 2, 6, 15], 9))

        // function inherit(origin, target) {
        //     function F() { };
        //     F.prototype = origin.prototype;
        //     target.prototype = new F();
        //     target.prototype.constructor = target;
        //     target.prototype.uber = origin.prototype;
        // }

        // var inherit = (function () {
        //     function F() { };
        //     return function (origin, target) {

        //         F.prototype = origin.prototype;
        //         target.prototype = new F();
        //         target.prototype.constructor = target;
        //         target.prototype.uber = origin.prototype;
        //     }
        // }())

        // function Fa() { }
        // function S() { }
        // Fa.prototype.a = function () {
        //     console.log('a')
        // }
        // inherit(Fa, S);

        // function deepClone(origin, target) {
        //     const toStr = Object.prototype.toString,
        //         str = '[object Array]';
        //     for (let prop in origin) {
        //         if (origin.hasOwnProperty(prop)) {
        //             if (typeof origin[prop] !== 'object' || origin[prop] === null) {
        //                 target[prop] = origin[prop]
        //             } else if (origin[prop] !== null && typeof origin[prop] === 'object') {
        //                 target[prop] = toStr.call(origin[prop]) === str ? [] : {};
        //                 deepClone(origin[prop], target[prop]);
        //             }
        //         }
        //     }
        //     return target;
        // }

        // var obj = {
        //     a: null,
        //     b: undefined,
        //     c: 'a',
        //     d: function () { },
        //     e: [1, 2],
        //     f: {
        //         v: 1
        //     }
        // }
        // var obj1 = {}
        // deepClone(obj, obj1)

        // var arr = [1, 1, 1, '1', 2, null, null, undefined, undefined, NaN, NaN, 'NaN', 'undefined', 'null'];
        // function unique(arr) {
        //     const newArr = [];
        //     arr.forEach(ele => {
        //         !newArr.includes(ele) && newArr.push(ele);
        //     });
        //     return newArr;
        // }
        // var arr1 = unique(arr)

        // function debounce(fn, time) {//防抖
        //     let timer = null;
        //     return function (...arg) {
        //         timer && clearTimeout(timer);
        //         timer = setTimeout(function () {
        //             fn.apply(null, arg);
        //         }, time)
        //     }
        // }

        // function throttle(fn, time) {//节流
        //     let timer = null;
        //     return function (...arg) {
        //         if (!timer) {
        //             fn.apply(null, arg)
        //             timer = setTimeout(function () {
        //                 timer = null
        //             }, time)
        //         }
        //     }
        // }

        // function sum(a, b) {
        //     if (a === 0) return b;
        //     if (b === 0) return a;
        //     let newA = a ^ b;
        //     let newB = (a & b) << 1;
        //     return sum(newA, newB);
        // }

        // function reverseStr(str) {
        //     var str = str.split('');
        //     var len = str.length;
        //     var mid = Math.floor(len / 2), temp;
        //     for (var i = 0, j = len - 1; i < mid, j > mid; i++ , j--) {
        //         temp = str[i];
        //         str[i] = str[j];
        //         str[j] = temp
        //     }
        //     return str.join('');
        // }
        // var str = reverseStr('hello world!')
    </script>
</body>

</html>